"""
This script generates a SQL migration file from the SQLModel definitions
in `app/db/models.py`. It is used to keep the Supabase database schema
in sync with the application's models.

When to use this script:
- After making any changes to the models in `app/db/models.py` that
  affect the database schema (e.g., adding, removing, or altering
  tables or columns).

How to use this script:
1. Make sure you have the project's dependencies installed. If not, run:
   `uv sync`
2. Run this script from the project's ROOT directory:
   `uv run python supabase/generate_schema.py`

This will create a new migration file in `supabase/migrations/`.
To apply the new schema and seed data to your local Supabase instance, run:
`npx supabase db reset`
"""
import os
import sys
from sqlalchemy import create_engine
from sqlalchemy.schema import CreateTable
from sqlalchemy.dialects import postgresql
from sqlalchemy import Enum as SQLAlchemyEnum

# Add the project root to the Python path to allow for absolute imports
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

from app.db.models import SQLModel

# Importing the models module registers the table models with SQLModel's metadata
from app.db import models


def generate_schema_sql():
    """Generates the SQL for creating all tables based on SQLModel metadata."""
    # We use a dummy postgresql engine. We don't connect to any real database.
    dialect = postgresql.dialect()
    metadata = SQLModel.metadata

    # Create ENUM types first
    enum_create_statements = []
    seen_enums = set()

    for table in metadata.sorted_tables:
        for column in table.columns:
            if isinstance(column.type, SQLAlchemyEnum):
                enum_type = column.type
                # The enum type object can be shared, so we process each unique enum only once
                if enum_type.enum_class in seen_enums:
                    continue
                
                seen_enums.add(enum_type.enum_class)
                
                # The name for the SQL ENUM type is the lowercase name of the Python Enum class
                type_name = enum_type.enum_class.__name__.lower()
                
                # The possible values of the enum
                values = ", ".join(f"'{v}'" for v in enum_type.enums)
                
                # We add IF NOT EXISTS to be safe when re-running migrations
                enum_create_statements.append(f"CREATE TYPE \"{type_name}\" AS ENUM ({values});")

    # Create a list of CREATE TABLE statements
    table_create_statements = []
    for table in metadata.sorted_tables:
        # The CreateTable construct can be compiled to a string for a specific dialect.
        # We add a semicolon at the end for valid SQL.
        create_table_sql = str(CreateTable(table).compile(dialect=dialect)).strip()
        table_create_statements.append(f"{create_table_sql};")

    all_statements = enum_create_statements + table_create_statements
    return "\n\n".join(all_statements)


if __name__ == "__main__":
    sql_schema = generate_schema_sql()
    
    # Get current timestamp for migration file name
    from datetime import datetime
    timestamp = datetime.utcnow().strftime('%Y%m%d%H%M%S')
    
    # Define the output path for the migration file
    # The script should be run from the root, so the path is relative to the root
    output_dir = "supabase/migrations"
    output_filename = f"{timestamp}_initial_schema.sql"
    output_path = os.path.join(output_dir, output_filename)
    
    # Write the generated SQL to the migration file
    with open(output_path, "w") as f:
        f.write("-- Generated by generate_schema.py from app/db/models.py\n\n")
        f.write(sql_schema)
        f.write("\n")

    print(f"âœ“ Schema saved to {output_path}") 